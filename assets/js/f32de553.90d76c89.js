"use strict";(self.webpackChunkdev_journal=self.webpackChunkdev_journal||[]).push([[898],{6783:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var a=n(4848),s=n(8453);const r={},i="Design patterns",o={id:"cs/design-patterns",title:"Design patterns",description:"What and why design patterns?",source:"@site/docs/cs/design-patterns.md",sourceDirName:"cs",slug:"/cs/design-patterns",permalink:"/dev-journal/cs/design-patterns",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docuSidebar",previous:{title:"Data type (Java 17)",permalink:"/dev-journal/cs/data-type"},next:{title:"Programming Foundations",permalink:"/dev-journal/category/programming-foundations"}},h={},l=[{value:"What and why design patterns?",id:"what-and-why-design-patterns",level:2},{value:"What about design principles?",id:"what-about-design-principles",level:2},{value:"Strategy pattern",id:"strategy-pattern",level:2},{value:"HAS-A is better than IS-A",id:"has-a-is-better-than-is-a",level:3},{value:"Adapter pattern",id:"adapter-pattern",level:2}];function c(e){const t={h1:"h1",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"design-patterns",children:"Design patterns"}),"\n",(0,a.jsx)(t.h2,{id:"what-and-why-design-patterns",children:"What and why design patterns?"}),"\n",(0,a.jsx)(t.p,{children:"Design patterns are all about reusing experience, design experience. Design patterns aren't algorithms, and they're not code. Design patterns are not specific solutions for specific kinds of software. Rather, design patterns are general solutions for common problems that crop up in all kinds of applications."}),"\n",(0,a.jsx)(t.p,{children:"A design pattern is usually expressed by a definition, and a class diagram."}),"\n",(0,a.jsx)(t.p,{children:"Why using design patterns? So we don't need to reinvent the wheel, we can often shortcut the design process by leveraging the hard work of other developers who have already gone through a similar exercise and found good solutions that we can use."}),"\n",(0,a.jsx)(t.h2,{id:"what-about-design-principles",children:"What about design principles?"}),"\n",(0,a.jsxs)(t.p,{children:["Principles are ",(0,a.jsx)(t.strong,{children:"general guidelines"})," while patterns are ",(0,a.jsx)(t.strong,{children:"specific solutions"})," often aimed at solving common object-oriented problems."]}),"\n",(0,a.jsxs)(t.p,{children:["The principle ",(0,a.jsx)(t.strong,{children:'"encapsulate what varies"'})," tells us to look for parts of our code that are frequently changing and separate them from the other code that isn't changing. The principle itself doesn't tell us at all how to actually do this. Instead, principles tell us to strive for a particular quality in our design, and this is often where patterns come in. Design patterns often demonstrate different ways of, for example, separating what varies in our design. e.g.Strategy pattern shows us how to separate out an object's behavior."]}),"\n",(0,a.jsxs)(t.p,{children:["The principle ",(0,a.jsx)(t.strong,{children:'"program to an interface, not an implementation"'})," tells us to use the super type (interface) to refer to objects rather than their specific type."]}),"\n",(0,a.jsx)(t.h2,{id:"strategy-pattern",children:"Strategy pattern"}),"\n",(0,a.jsx)(t.p,{children:"It defines a family of algorithms, encapsulates each one and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it."}),"\n",(0,a.jsx)(t.h3,{id:"has-a-is-better-than-is-a",children:"HAS-A is better than IS-A"}),"\n",(0,a.jsxs)(t.p,{children:["IS-A is an inheritance relationship: A mallard duck is a duck. HAS-A is a relationship of composition: A mallard duck has a fly behavior. Instead of ducks inheriting their fly behavior and quack behavior, we're now composing the ducks with a fly behavior and a quack behavior. When we put two classes together, with composition, instead of inheriting behavior, an object can then instead delegate that behavior, to the composed object. And this aligns with the principle ",(0,a.jsx)(t.strong,{children:'"use composition rather than inheritance"'}),", because the composition gives us a more flexible design, which allows us to easily reuse flying and quacking behavior."]}),"\n",(0,a.jsx)(t.h2,{id:"adapter-pattern",children:"Adapter pattern"}),"\n",(0,a.jsx)(t.p,{children:"It converts the interface of a class into another interface that clients expect. It allows classes to work together that couldn't otherwise because of incompatible interfaces."}),"\n",(0,a.jsx)(t.p,{children:"For example, when using a vendor's class to achieve certain goals, at some point, we may want to use a different Vendor class (perhaps that's better, cheaper or faster). The only problem is that the new Vendor class has a different interface than your existing Vendor class. How to make our system work with the new vendor? We create an Adapter class that implements the existing interface and then talks to the Vendor's class to carry out request. If we do our job right, the existing system and the new Vendor class will do what they've always done without the need for code changes. It's the Adapter class that will handle the work of translating the request to the new Vendor class."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(6540);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);