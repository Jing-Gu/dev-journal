"use strict";(self.webpackChunkdev_journal=self.webpackChunkdev_journal||[]).push([[373],{9717:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var s=n(4848),a=n(8453);const i={},r="OOP - Object oriented programming",l={id:"programming fondations/oop",title:"OOP - Object oriented programming",description:"Object-oriented programming allows concepts from the real world to be represented by code that contains both the data and related behavior. The concepts are normally modeled as classes, with properties for data and methods for the behavior, and the specific instances of these classes are called objects.",source:"@site/docs/programming fondations/oop.md",sourceDirName:"programming fondations",slug:"/programming fondations/oop",permalink:"/dev-journal/programming fondations/oop",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docuSidebar",previous:{title:"Basics",permalink:"/dev-journal/programming fondations/basics"},next:{title:"Operator, operand",permalink:"/dev-journal/programming fondations/operator"}},o={},c=[{value:"Class and object",id:"class-and-object",level:2},{value:"Static member",id:"static-member",level:3},{value:"Non-static member",id:"non-static-member",level:3},{value:"OOP 4 main principles",id:"oop-4-main-principles",level:2},{value:"Encapsulation",id:"encapsulation",level:3},{value:"Access modifier",id:"access-modifier",level:4},{value:"Inheritance",id:"inheritance",level:3},{value:"Different types of inheritance",id:"different-types-of-inheritance",level:4},{value:"Abstraction",id:"abstraction",level:3},{value:"Abstract class",id:"abstract-class",level:4},{value:"Interface",id:"interface",level:4},{value:"Polymorphism",id:"polymorphism",level:3},{value:"OOP anti-patterns and code smells",id:"oop-anti-patterns-and-code-smells",level:2},{value:"Class bloat",id:"class-bloat",level:3},{value:"Long methods",id:"long-methods",level:3},{value:"God object",id:"god-object",level:3},{value:"Feature envy",id:"feature-envy",level:3}];function h(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"oop---object-oriented-programming",children:"OOP - Object oriented programming"}),"\n",(0,s.jsxs)(t.p,{children:["Object-oriented programming allows concepts from the real world to be represented by code that contains both the data and related behavior. The concepts are normally modeled as ",(0,s.jsx)(t.strong,{children:"classes"}),", with ",(0,s.jsx)(t.strong,{children:"properties"})," for data and ",(0,s.jsx)(t.strong,{children:"methods"})," for the behavior, and the specific instances of these classes are called ",(0,s.jsx)(t.strong,{children:"objects"}),"."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"The contents about OOP below are explained with Java examples."})}),"\n",(0,s.jsx)(t.h2,{id:"class-and-object",children:"Class and object"}),"\n",(0,s.jsx)(t.p,{children:"A class represents or models a real object in code via a blueprint, which contains a set of attributes and behaviors that define that object."}),"\n",(0,s.jsx)(t.p,{children:"For example, to define a tree class, it may have attributes such as height, trunkDiameter, treeType and behavior such as growing."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",metastring:'title="Tree.java"',children:'import java.awt.*;\n\npublic class Tree {\n    double height;\n    double trunkDiameter;\n    TreeType treeType;\n\n    static Color TRUNK_COLOR = new Color(102, 51, 0);\n\n    Tree(double height, double trunkDiameter, TreeType treeType){\n        this.height = height;\n        this.trunkDiameter = trunkDiameter;\n        this.treeType = treeType;\n    }\n\n    void grow() {\n        this.height = this.height + 10;\n        if (this.treeType == TreeType.OAK) {\n            this.trunkDiameter = this.trunkDiameter + 5;\n        }\n        if (this.treeType == TreeType.MAPLE) {\n            this.trunkDiameter = this.trunkDiameter + 10;\n        }\n        if (this.treeType == TreeType.PECAN) {\n            this.trunkDiameter = this.trunkDiameter + 15;\n        }\n        if (this.treeType == TreeType.WALNUT) {\n            this.trunkDiameter = this.trunkDiameter + 20;\n        }\n        if (this.treeType == TreeType.PINE) {\n            this.trunkDiameter = this.trunkDiameter + 25;\n        }\n    }\n\n    void announceTallTree() {\n        if (this.height > 100) {\n            System.out.println("That is a tall tree" + this.treeType);\n        } else {\n            System.out.println("That is a short tree" + this.treeType);\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",metastring:'title="TreeType.java"',children:"public enum TreeType {\n    OAK,\n    MAPLE,\n    PECAN,\n    WALNUT,\n    PINE\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Remember that the class is just a blueprint, no tree has been created by this tree class yet. This class is telling us: if we want to create a tree, this is how it will look like."}),"\n",(0,s.jsx)(t.p,{children:"It is the method constructor that brings the blueprint to life. Constructor normally has the same class name. When the constructor is used, it will create a tree with the corresponding parameters."}),"\n",(0,s.jsxs)(t.p,{children:["We can then call the constructor (normally in another class to keep code separate) to create the tree object. ",(0,s.jsx)(t.code,{children:"new Tree()"})," creates a tree from the tree class, but it will be thrown away if it is not assigned to any variable. Assign it to a variable called myTree, then this object can access all attributes and methods of the tree class."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",metastring:'title="Main.java"',children:"public class Main {\n    public static void main(String[] args) {\n        Tree myTree = new Tree(25, 5, TreeType.PINE);\n\n        myTree.grow();\n\n        myTree.announceTallTree();\n\n        System.out.println(myTree.treeType);\n        System.out.println(myTree.height);\n        System.out.println(myTree.trunkDiameter);\n        System.out.println(Tree.TRUNK_COLOR);\n\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"static-member",children:"Static member"}),"\n",(0,s.jsxs)(t.p,{children:["Static member is part of a class that is ",(0,s.jsx)(t.strong,{children:"accessible through the class and belongs to that class"}),", means that attribute or behavior is not based on any particular instance, but rather belongs to all instances of that class. The static member is marked with ",(0,s.jsx)(t.code,{children:"static"})," and is accessed with class directly, such as ",(0,s.jsx)(t.code,{children:"Tree.TRUNK_COLOR"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"non-static-member",children:"Non-static member"}),"\n",(0,s.jsxs)(t.p,{children:["Non-static member is part of a class that is ",(0,s.jsx)(t.strong,{children:"accessible with an instance and belongs to that instance"}),", means that we have to create an instance in order to access the value of a non-static attribute or method. ",(0,s.jsx)(t.code,{children:"height"}),", ",(0,s.jsx)(t.code,{children:"trunkDiameter"}),", ",(0,s.jsx)(t.code,{children:"treeType"})," are all non-static attributes. The method ",(0,s.jsx)(t.code,{children:"announceTallTree"}),"() is a non-static method that uses instance\u2019s height and treeType to calculate."]}),"\n",(0,s.jsxs)(t.p,{children:["Non-static members are referred as instance members, because an instance must be created to use or access those members, such as ",(0,s.jsx)(t.code,{children:"myTree.height"}),", ",(0,s.jsx)(t.code,{children:"myTree.announceTallTree()"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"oop-4-main-principles",children:"OOP 4 main principles"}),"\n",(0,s.jsx)(t.p,{children:"OOP helps programmers to create complex programs by grouping together related data and functions. Four main principles of OOP are: encapsulation, abstraction, inheritance, polymorphism."}),"\n",(0,s.jsx)(t.h3,{id:"encapsulation",children:"Encapsulation"}),"\n",(0,s.jsxs)(t.p,{children:["It refer to binding state and behavior together into a single unit, essentially means to ",(0,s.jsx)(t.strong,{children:"hide data within a class, preventing anyone outside the class from directly interacting with it"}),". It doesn\u2019t mean that other classes can\u2019t interact at all, but they should only interact with attributs of another object through that class methods, which are getter and setter."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"myTree.height"})," is directly accessing the tree class attribute, if the attribute changes (e.g. name or the way it's stored), any class that uses the tree class will also have to change. This makes code heavily dependent on each other."]}),"\n",(0,s.jsx)(t.p,{children:"To achieve the encapsulation, we need a clear interface through public methods between a given class and the rest of the program, to prevent other classes having direct access to certain attributes."}),"\n",(0,s.jsx)(t.h4,{id:"access-modifier",children:"Access modifier"}),"\n",(0,s.jsx)(t.p,{children:"Different access modifier determine where certain variables and methods can be accessed in our code."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"private: only visible in the class where the member lives in"}),"\n",(0,s.jsx)(t.li,{children:"no modifier: visible in the package where the member lives in"}),"\n",(0,s.jsx)(t.li,{children:"protected: visible in the package and all subclasses"}),"\n",(0,s.jsx)(t.li,{children:"public: accessible everywhere within the program"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Access modifiers allow other classes to access data indirectly through a known pathway:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["restrict each attribute as ",(0,s.jsx)(t.code,{children:"private"})]}),"\n",(0,s.jsxs)(t.li,{children:["write ",(0,s.jsx)(t.code,{children:"public"})," getters and setters"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",metastring:'title="Tree.java"',children:"public class Tree {\n  private double height;\n  private double trunkDiameter;\n  private TreeType treeType;\n\n  public double getHeight() {\n    return height;\n  }\n\n  public double getTrunkDiameter() {\n    return trunkDiameter;\n  }\n\n  public TreeType getTreeType() {\n    return treeType;\n  }\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"We may also want some attributes to be read-only from the outside, which means we only define a getter but not a setter. The variable can be only referenced but not changed."}),"\n",(0,s.jsx)(t.h3,{id:"inheritance",children:"Inheritance"}),"\n",(0,s.jsxs)(t.p,{children:["Inheritance allows us to create class hierarchies where classes inherit properties and behaviors from other classes. The class that inherits the properties is called the ",(0,s.jsx)(t.strong,{children:"subclass"})," or child class. The class that's being inherited from is called the ",(0,s.jsx)(t.strong,{children:"superclass"})," or the parent class. That's to say, the subclass inherits from the superclass."]}),"\n",(0,s.jsx)(t.p,{children:"Typically we think of one class inheriting from another if they share an IS-A relationship. For example, if a cat is an animal, then a cat should inherit from the animal class. We can extend this further with other types of animals. In each case, we're reusing the implementation of the classes we inherit from."}),"\n",(0,s.jsx)(t.p,{children:"Benefits of inheritance"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Promote code reusibility, avoid duplicating code in two different places"}),"\n",(0,s.jsx)(t.li,{children:"Additions or modifications to the superclass will automatically affect all subclasses"}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"different-types-of-inheritance",children:"Different types of inheritance"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Single-level inheritance"})}),"\n",(0,s.jsx)(t.p,{children:"One superclass (e.g.employee) has only one subclass (e.g.salesperson)"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Hierarchical inheritance"})}),"\n",(0,s.jsx)(t.p,{children:"One superclass (e.g.employee) has many subclasses (e.g.salesperson, analyst)"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Multi-level inheritance"})}),"\n",(0,s.jsx)(t.p,{children:"A class can inherit from one class, but also be the parent of another class. e.g. The employee class can inherit from another class called person."}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"In Java, a class can only have one super class, but multiple subclasses."})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public class Employee {\n    private String name;\n    protected double salary;\n    private int age;\n\n    public Employee(String name, double salary, int age) {\n        this.name = name;\n        this.salary = salary;\n        this.age = age;\n    }\n    public String getName() {\n        return this.name;\n    }\n\n    public double getSalary() {\n        return this.salary;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n\n    public void raiseSalary() {\n        this.salary = this.salary * 1.5;\n    }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Use keyword ",(0,s.jsx)(t.code,{children:"extends"})," to achieve inheritance in the subclass. Modify the subclass constructor to use properties from the superclass by using keyword ",(0,s.jsx)(t.code,{children:"super"}),", which refers to the superclass constructor."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public class Salesperson extends Employee {\n\n    private double commissionPercentage;\n\n    public Salesperson (String name, double salary, int age, double commissionPercentage) {\n        super(name, salary, age);\n        this.commissionPercentage = commissionPercentage;\n    }\n\n    public double getCommissionPercentage() {\n        return commissionPercentage;\n    }\n}\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public class Analyst extends Employee {\n    public Analyst(String name, double salary, int age) {\n        super(name, salary, age);\n    }\n\n    public double getAnnualBonus() {\n        return super.salary * .5;\n    }\n}\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["To make certain attribute available to the subclasses, use access modifier ",(0,s.jsx)(t.code,{children:"protected"}),". And the subclass can access by using ",(0,s.jsx)(t.code,{children:"super."}),", such as super.salary."]})}),"\n",(0,s.jsx)(t.h3,{id:"abstraction",children:"Abstraction"}),"\n",(0,s.jsx)(t.p,{children:"Abstraction helps to hide implementation complexity, which may come from an algorithm, API or design. Think of it as a coffee machine which hides the implementation details of how coffee is made. To make a coffee, we only need to interact with the interface, by providing inputs - coffee pod and water, we get outputs - a cup of coffee."}),"\n",(0,s.jsx)(t.p,{children:"A system with abstraction only shows essential details and keeps everything else hidden. When multiple programmers work together on one program, it\u2019s best if our section is able to function without knowledge of the inner workings of another colleague\u2019s section. All we need to know are the inputs, outputs, and a general idea of what the system does."}),"\n",(0,s.jsx)(t.p,{children:"There are 2 ways to achieve abstraction: abstract class, and interface."}),"\n",(0,s.jsx)(t.h4,{id:"abstract-class",children:"Abstract class"}),"\n",(0,s.jsxs)(t.p,{children:["In Java, an abstract class allows us to add abstraction. An abstract class is like a template class where some of the functionality is not implemented yet. This means we cannot instantiate an abstract class but other classes ",(0,s.jsx)(t.strong,{children:"extends"})," the abstract class and implement the appropriate functionality."]}),"\n",(0,s.jsxs)(t.p,{children:["For example,to read a file possibily in different ways, we can create an abstract class ",(0,s.jsx)(t.code,{children:"AbstractFileReader"}),". This class will have the basic operations for interacting with the file and retrieving the files contents. To implement, we'll need to create a subclass that extends AbstractFileReader class in order to use it, e.g. ",(0,s.jsx)(t.code,{children:"DigitsOnlyFileReader"})," - a concrete class that extends AbstractFileReader."]}),"\n",(0,s.jsx)(t.p,{children:"Other concrete file reader classes can use the algorithm without worrying about the implementation. They just have to override the parse line method. With the AbstractFileReader, we can easily create functionality that reads the file and converts its contents to all uppercase, lowercase or whatever we want. All we need to do is create a new class that extends the AbstractFileReader class and implements the parse line functionality."}),"\n",(0,s.jsx)(t.h4,{id:"interface",children:"Interface"}),"\n",(0,s.jsx)(t.p,{children:"An interface is a set of method signatures for to-be-implemented functionality. It's kind of like a specification for a set of behavior without the implementation. Same as an abstract class, an interface cannot be instantiated."}),"\n",(0,s.jsxs)(t.p,{children:["To use an interface, another class implements it, using the ",(0,s.jsx)(t.code,{children:"implements"})," keyword."]}),"\n",(0,s.jsx)(t.h3,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,s.jsx)(t.p,{children:"Polymorphism is the ability for an object or function to take many forms. It helps reducing complexity and promotes reusable code."}),"\n",(0,s.jsx)(t.p,{children:"Java supports two types of polymorphism, runtime polymorphism and compile-time polymorphism."}),"\n",(0,s.jsx)(t.p,{children:"oddListy and Listy are both ArrayLists. They both have all the functionality of an ArrayList, including that add functionality. However, the implementations of each add algorithm are different and are determined at runtime based on the instances original type, hence why it's called runtime polymorphism."}),"\n",(0,s.jsx)(t.h2,{id:"oop-anti-patterns-and-code-smells",children:"OOP anti-patterns and code smells"}),"\n",(0,s.jsx)(t.p,{children:"Code smells are indicators or warning signs in our code that suggest potential problems. They do not necessarily indicate a bug, but rather areas where our code could be improved."}),"\n",(0,s.jsx)(t.h3,{id:"class-bloat",children:"Class bloat"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Problem: A large class that handles many responsibilities"}),"\n",(0,s.jsx)(t.li,{children:"Impact: Challenging to maintain and understand because we might not understand the side effects it has or what could break by changing it"}),"\n",(0,s.jsx)(t.li,{children:"Fix: Refactor into smaller classes"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"long-methods",children:"Long methods"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Problem: Long method with many responsibilities"}),"\n",(0,s.jsx)(t.li,{children:"Impact: Hard to read or understand"}),"\n",(0,s.jsx)(t.li,{children:"Fix: Refactor into smaller components"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"god-object",children:"God object"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Problem: A single object that knows and does too much"}),"\n",(0,s.jsx)(t.li,{children:"Impact: It often has many attributes and methods, making it a single point of failure for the application, usually seen as an extreme class bloat"}),"\n",(0,s.jsx)(t.li,{children:"Fix: Refactor into smaller components"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"feature-envy",children:"Feature envy"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Problem: One class has a strong interest in the internal details or attributes of another class, more so than in its own class"}),"\n",(0,s.jsx)(t.li,{children:"Impact: Create excessive coupling, making the two classes less independent"}),"\n",(0,s.jsx)(t.li,{children:"Fix: Move the method over to the class it envies, or define an interface between the two classes"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var s=n(6540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);