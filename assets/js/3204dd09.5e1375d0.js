"use strict";(self.webpackChunkdev_journal=self.webpackChunkdev_journal||[]).push([[333],{4901:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var s=n(4848),i=n(8453);const a={},r="Data structure",o={id:"cs/data-structure",title:"Data structure",description:"Data structures are where we store and group the data together.",source:"@site/docs/cs/data-structure.md",sourceDirName:"cs",slug:"/cs/data-structure",permalink:"/dev-journal/cs/data-structure",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docuSidebar",previous:{title:"Algorithms",permalink:"/dev-journal/cs/algorithms"},next:{title:"Data type (Java 17)",permalink:"/dev-journal/cs/data-type"}},d={},l=[{value:"How to choose a data structure?",id:"how-to-choose-a-data-structure",level:2},{value:"Array",id:"array",level:2},{value:"Collections",id:"collections",level:2},{value:"LinkedList",id:"linkedlist",level:3},{value:"Stack",id:"stack",level:3},{value:"Queue",id:"queue",level:3},{value:"TreeSet",id:"treeset",level:3}];function h(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"data-structure",children:"Data structure"}),"\n",(0,s.jsx)(t.p,{children:"Data structures are where we store and group the data together."}),"\n",(0,s.jsxs)(t.p,{children:["In a to-do app, the to-do items are the ",(0,s.jsx)(t.strong,{children:"data"}),", and the list we put them in is the ",(0,s.jsx)(t.strong,{children:"data structure"}),", where gives us a way to access and modify the data."]}),"\n",(0,s.jsx)(t.p,{children:"Data structures also tell us how the items relate to each other. For example, is order important? Are duplicates allowed or do they all have to be unique and different? The answers to these questions will vary for different use cases, and the data structure we choose will be determined by answers to those questions."}),"\n",(0,s.jsx)(t.h2,{id:"how-to-choose-a-data-structure",children:"How to choose a data structure?"}),"\n",(0,s.jsx)(t.p,{children:"Things to consider:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Do we know in advance how many items are going to be in the data structure?"}),"\n",(0,s.jsx)(t.li,{children:"Do we care duplicates? Or only unique is allowed."}),"\n",(0,s.jsx)(t.li,{children:"Is order important?"}),"\n",(0,s.jsx)(t.li,{children:"Performance consideration. Some is quicker at deleting, another is quicker at retrieving. Think about what will be done with the data. Are we going to change and update it a lot, or is it going to stay the same the whole time."}),"\n",(0,s.jsx)(t.li,{children:"Think of memory."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"array",children:"Array"}),"\n",(0,s.jsxs)(t.p,{children:["Array contains a ",(0,s.jsx)(t.em,{children:"fixed"})," number of elements of the ",(0,s.jsx)(t.em,{children:"same type"}),". Upon creating an array, we have to say upfront how many elements are going to be in it, means that we have to set the length and it can't be changed later."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"String[] weekdays = new String[7]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When creating an array, if we don't say what kind of values are going to be, Java will just use the default value ",(0,s.jsx)(t.code,{children:"null"})," for that type."]}),"\n",(0,s.jsx)(t.p,{children:"We can set values by accessing index, but it won't be efficient to acess index one by one."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'weekdays[0] = "Mon";\n'})}),"\n",(0,s.jsx)(t.p,{children:"Another way to set arrays is when we create them, instead of saying how many values are going to be in it, we can say straight away, what all the values are."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'weekdays = new String[]{"Mon", "Tue", "Wed"}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"collections",children:"Collections"}),"\n",(0,s.jsxs)(t.p,{children:["Most Java data structure implements the Collection interface. ",(0,s.jsx)(t.strong,{children:"List"}),", ",(0,s.jsx)(t.strong,{children:"Queue"})," and ",(0,s.jsx)(t.strong,{children:"Set"})," are sub interfaces that are ",(0,s.jsx)(t.strong,{children:"extended"})," from the Collection interface. There are concrete classes that ",(0,s.jsx)(t.strong,{children:"implement"})," those sub interfaces, such as: ArrayList implements List, PriorityQueue implements Queue, HashSet implements Set."]}),"\n",(0,s.jsxs)(t.p,{children:["This structure is referred as the ",(0,s.jsx)(t.strong,{children:"Collections Framework"}),", which is a backbone of the Java data structure. It's handy when most classes are extended from the Collections, means the consistent API and the same methods used across all classes such as add(), remove(), contains() etc."]}),"\n",(0,s.jsxs)(t.p,{children:["Above the Collection interface, there is another interface: ",(0,s.jsx)(t.strong,{children:"Iterable"}),", the very top of the collections framework, means that any class in this framework can be iterated over such as forEach()."]}),"\n",(0,s.jsx)(t.p,{children:"There are many difference between Array adn Collections."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Collections can change size, no need to specify the items needed upon creation."}),"\n",(0,s.jsxs)(t.li,{children:["Collections can not hold primitive types, ",(0,s.jsx)(t.code,{children:"List<int>"})," is wrong, ",(0,s.jsx)(t.code,{children:"List<Integer>"})," is correct."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"linkedlist",children:"LinkedList"}),"\n",(0,s.jsx)(t.p,{children:"Each element in the list has a reference to the next element and the previous elements. LinkedList keeps items in the same order when adding them. An item can be added between the existed items by passing the index to add()."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'import java.util.LinkedList;\n\npublic class LinkedListExample {\n    public static void main(String[] args) {\n      //highlight-start\n        LinkedList<String> shoppingList = new LinkedList<>();\n      //highlight-end\n\n        shoppingList.add("apple");\n        shoppingList.add("banana");\n        shoppingList.add("pear");\n\n        System.out.println(shoppingList); //[apple, banana, pear]\n\n        shoppingList.add(1, "mango");\n\n        System.out.println(shoppingList); //[apple, mango, banana, pear]\n    }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["LinkedLists also comes with some handy methods called ",(0,s.jsx)(t.code,{children:"addFirst"}),", ",(0,s.jsx)(t.code,{children:"addLast"}),", ",(0,s.jsx)(t.code,{children:"removeFirst"})," and ",(0,s.jsx)(t.code,{children:"removeLast"})," to add or remove elements to the front or the back of the list."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"LinkedList and ArrayList look similar, but behind the scene differences are:\nArrayList uses an array, which allows for fast random access but slow insertion and deletion. While LinkedList uses a doubly linked list, which allows for fast insertion and deletion but slow random access (because linkedList has to go through and see what one comes next until it gets to the one)."})}),"\n",(0,s.jsx)(t.p,{children:"LinkedList is NOT synchronized, which is a good thing in terms of performance and memory. But it does mean that it's not thread safe. So if we've got multiple threads trying to modify the list at the same time, they might overwrite each other's changes. Luckily, there is way to make LinkedLists synchronized."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"import java.util.Collections;\nimport java.util.List;\n\nList<String> syncShippingList = Collections.synchronizedList(shoppingList);\n"})}),"\n",(0,s.jsx)(t.p,{children:"Create a new List and make a copy of the shopping list, put it in a list that is synchronized, this syncShippingList is the same as the old shoppingList. Now it's thread safe and we can continue using LinkedList."}),"\n",(0,s.jsx)(t.h3,{id:"stack",children:"Stack"}),"\n",(0,s.jsx)(t.p,{children:"The first element added is the last one being taken out. Think of it like a real life stack of plates. When we stack plates on top of each other, and we want to pick one up, we would take it from the top of the pile."}),"\n",(0,s.jsxs)(t.p,{children:["There are multiple ways to create a stack in Java. And neither of them are perfect. There is a stack class, but it has a few limitations. For example, it lets us remove elements from anywhere in the stack. If we imagine a real life stack of plates, this isn't very stack-like behavior. So it's generally recommended to use the ",(0,s.jsx)(t.code,{children:"Deque"})," interface instead."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'import java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class StackExample {\n    public static void main(String[] args) {\n      //highlight-start\n        Deque<String> stack = new ArrayDeque<>();\n      //highlight-end\n        stack.push("first request");\n        stack.push("second request");\n        stack.push("third request");\n        System.out.println(stack); // [third request, second request, first request]\n        System.out.println(stack.peek()); //third request\n        stack.pop();\n        System.out.println(stack); //[second request, first request]\n    }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Deque"})," is an interface, and the concrete type could be ",(0,s.jsx)(t.code,{children:"ArrayDeque"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"peek()"})," is to get the first element from the top of the stack."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"pop()"})," is to remove the first element from the top of the stack."]}),"\n",(0,s.jsx)(t.h3,{id:"queue",children:"Queue"}),"\n",(0,s.jsx)(t.p,{children:"The first item we add is the first item we take out. Think of it like a real queue of people waiting outside a store. The first person that joins the queue is the first person that gets served."}),"\n",(0,s.jsxs)(t.p,{children:["One way to make a queue is with an ",(0,s.jsx)(t.code,{children:"ArrayDeque"}),", which is the same class used to create a stack."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'import java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class QueueExample {\n    public static void main(String[] args) {\n      // implement queue with ArrayDeque\n      //highlight-start\n        Queue<String> queue = new ArrayDeque<>();\n      //highlight-end\n      // or with LinkedList\n      //highlight-start\n        Queue<String> queue = new LinkedList<>();\n      //highlight-end\n        queue.offer("person one");\n        queue.offer("person two");\n        queue.offer("person three");\n        System.out.println(queue); //[person one, person two, person three]\n        System.out.println(queue.peek()); //person one\n        queue.poll();\n        System.out.println(queue); //[person two, person three]\n    }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"offer()"})," is to add items to a queue."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"peek()"})," is to the see the first element of the queue, same as the way in stack. However there's no ",(0,s.jsx)(t.code,{children:"pop()"})," in queue, the same behavior is achieved by ",(0,s.jsx)(t.code,{children:"poll()"}),", to remove the first element."]}),"\n",(0,s.jsxs)(t.p,{children:["We could actually change this ",(0,s.jsx)(t.code,{children:"ArrayDeque"})," class to some other concrete implementation, such as ",(0,s.jsx)(t.code,{children:"LinkedList"}),". And nothing else will be changed. LinkedList is quite a common implementation to use for a queue. But in most cases, the ArrayDeque has better performance. Linkedlist is better if we're removing the current element during iteration."]}),"\n",(0,s.jsx)(t.h3,{id:"treeset",children:"TreeSet"}),"\n",(0,s.jsx)(t.p,{children:"TreeSet stores unique elements in a sorted order."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'import java.util.Set;\nimport java.util.TreeSet;\n\npublic class TreeSetExample {\n    public static void main(String[] args) {\n      //highlight-start\n        Set<Integer> treeSet = new TreeSet<>();\n      //highlight-end\n        treeSet.add(1);\n        treeSet.add(300);\n        treeSet.add(47);\n        treeSet.add(6);\n        treeSet.add(47);\n        System.out.println(treeSet); //[1, 6, 47, 300]\n\n      //highlight-start\n        Set<String> wordSet = new TreeSet<>();\n      //highlight-end\n        wordSet.add("tiger");\n        wordSet.add("cat");\n        wordSet.add("bear");\n        System.out.println(wordSet); //[bear, cat, tiger]\n    }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"add()"})," is to add items to a TreeSet"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"remove()"})," is to remove items from a TreeSet."]}),"\n",(0,s.jsx)(t.p,{children:"TreeSet can't store duplicate values."}),"\n",(0,s.jsx)(t.p,{children:"TreeSet stores elements by defaults in ascending order from lowest to highest, so it doesn't care the order that we add the items in. If strings are stored as TreeSet, they will be put in the alphabetical order."}),"\n",(0,s.jsx)(t.p,{children:"We can define a different way to order strings, for example by length."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'      //highlight-start\n      Set<String> wordSet = new TreeSet<>(Comparator.comparing(String:: length));\n      //highlight-end\n      wordSet.add("tiger");\n      wordSet.add("cat");\n      wordSet.add("wolf");\n      wordSet.add("bear");\n      System.out.println(wordSet); //[cat, wolf, tiger]\n'})}),"\n",(0,s.jsx)(t.p,{children:"Bear is not showing, because both wolf and bear has 4 letter, and when we compare strings by length, the treeSet is counting that as a duplicate, so not included."}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"It's good practice to use the parent's type on the left hand side. So that means that if we change mind about which concrete type to use later, we can just change the right hand side and leave the left hand side as it is."})})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);